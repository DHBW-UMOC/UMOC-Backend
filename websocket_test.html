<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"="width=device-width, initial-scale=1.0">
    <title>UMOC WebSocket Test Client</title>
    <!-- Add Socket.IO client library -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 15px;
        }

        .message-container {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            margin-top: 10px;
            background-color: #f9f9f9;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
        }

        .received {
            background-color: #e3f2fd;
        }

        .sent {
            background-color: #e8f5e9;
            text-align: right;
        }

        .error {
            background-color: #ffebee;
            color: #c62828;
        }

        .input-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .status {
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            font-weight: bold;
        }

        .connected {
            background-color: #e8f5e9;
            color: #2e7d32;
        }

        .disconnected {
            background-color: #ffebee;
            color: #c62828;
        }

        .chat-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            margin-top: 10px;
        }

        .chat-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .chat-item:hover {
            background-color: #f5f5f5;
        }

        .chat-item.selected {
            background-color: #e3f2fd;
        }

        .text-muted {
            color: #757575;
            font-size: 0.9em;
        }

        .badge {
            display: inline-block;
            padding: 3px 7px;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
            color: #fff;
            text-align: center;
            white-space: nowrap;
            vertical-align: middle;
            background-color: #5cb85c;
            border-radius: 10px;
            margin-left: 5px;
        }

        .ping-status {
            display: inline-block;
            margin-left: 10px;
            font-size: 0.9em;
        }

        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }

        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
        }

        .tab.active {
            border-color: #ddd;
            border-radius: 4px 4px 0 0;
            background-color: #f8f8f8;
        }

        /* New user management styles */
        .user-selector {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f8f8f8;
        }

        .user-profiles {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .user-profile {
            padding: 8px;
            margin-bottom: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-profile:hover {
            background-color: #e9ecef;
        }

        .user-profile.active {
            background-color: #e3f2fd;
            border-color: #90caf9;
        }

        .profile-actions {
            display: flex;
            gap: 5px;
        }

        .btn-sm {
            padding: 3px 8px;
            font-size: 12px;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        /* New chat styles */
        .typing-indicator {
            padding: 8px;
            color: #666;
            font-style: italic;
            margin: 5px 0;
            display: none;
            background-color: #f0f0f0;
            border-radius: 8px;
        }

        .chat-message {
            margin-bottom: 8px;
            max-width: 80%;
            padding: 10px;
            border-radius: 10px;
            position: relative;
        }

        .incoming {
            background-color: #e3f2fd;
            margin-right: auto;
            border-bottom-left-radius: 2px;
        }

        .outgoing {
            background-color: #e8f5e9;
            margin-left: auto;
            border-bottom-right-radius: 2px;
            text-align: right;
        }

        .message-content {
            word-break: break-word;
        }

        .message-info {
            font-size: 0.75em;
            color: #757575;
            margin-top: 4px;
        }

        .read-indicator {
            margin-left: 5px;
            color: #4CAF50;
        }

        .load-more-btn {
            display: block;
            margin: 10px auto;
            background-color: #f5f5f5;
            color: #333;
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .load-more-btn:hover {
            background-color: #e0e0e0;
        }

        #chatMessages {
            height: 300px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            margin-top: 10px;
            display: flex;
            flex-direction: column;
        }
    </style>
</head>

<body>
    <h1>UMOC WebSocket Test Client</h1>

    <div class="container">
        <!-- User selector panel -->
        <div class="card">
            <h2>User Management</h2>
            <div class="user-selector">
                <div class="input-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Enter username" />
                </div>
                <div class="input-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" placeholder="Enter password" />
                </div>
                <button id="saveUserBtn">Save User</button>

                <h3>Saved Users</h3>
                <div class="user-profiles" id="userProfiles"></div>
                <!-- User profiles will be added here -->
            </div>
        </div>
    </div>

    <div class="card">
        <h2>Connection</h2>
        <div class="input-group">
            <label for="serverUrl">Server URL</label>
            <input type="text" id="serverUrl" value="http://localhost:5000" />
        </div>
        <div class="input-group">
            <label for="loginUsername">Current Username: <span id="currentUsername">None</span></label>
        </div>
        <button id="loginBtn">Login & Connect</button>
        <div class="input-group">
            <label for="sessionID">Session ID (if already logged in)</label>
            <input type="text" id="sessionID" placeholder="Enter your session ID" />
        </div>
        <button id="connectBtn">Connect with Session ID</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
        <div style="margin-top: 10px;">
            Status: <span id="connectionStatus" class="status disconnected">Disconnected</span>
            <span id="pingStatus" class="ping-status"></span>
            <span id="reconnectStatus" class="text-muted"></span>
        </div>
    </div>

    <div class="card">
        <h2>Messages</h2>
        <div class="message-container" id="messageLog"></div>
    </div>

    <div class="card">
        <h2>Chats</h2>
        <div class="tab-container">
            <div class="tab active" id="directChatsTab">Direct Chats</div>
            <div class="tab" id="groupChatsTab">Group Chats</div>
        </div>
        <button id="refreshChatsBtn" disabled>Refresh Chats</button>
        <div class="chat-list" id="chatsList"></div>
    </div>

    <div class="card">
        <h2>Send Message</h2>
        <div class="input-group">
            <label for="recipientId">Recipient ID</label>
            <input type="text" id="recipientId" placeholder="Enter recipient user ID" />
        </div>
        <div class="input-group">
            <label for="messageContent">Message Content</label>
            <textarea id="messageContent" rows="3" placeholder="Type your message here"></textarea>
        </div>
        <div class="input-group">
            <label for="messageType">Message Type</label>
            <select id="messageType">
                <option value="text">Text</option>
                <option value="image">Image</option>
                <option value="item">Item</option>
            </select>
        </div>
        <div class="input-group">
            <label>
                <input type="checkbox" id="isGroup" /> Is Group Message
            </label>
        </div>
        <button id="sendMessageBtn" disabled>Send Message</button>
    </div>

    <div class="card">
        <h2>Get Messages</h2>
        <div class="input-group">
            <label for="chatId">Chat ID (User ID or Group ID)</label>
            <input type="text" id="chatId" placeholder="Enter chat ID" />
        </div>
        <div class="input-group">
            <label for="isGroupChat">
                <input type="checkbox" id="isGroupChat" /> Is Group Chat
            </label>
        </div>
        <button id="getMessagesBtn" disabled>Get Messages</button>
    </div>

    <div class="card">
        <h2>Get Chats</h2>
        <button id="getChatsBtn" disabled>Get All Chats</button>
    </div>

    <div class="card">
        <h2>Add Contact</h2>
        <div class="input-group">
            <label for="contactUsername">Contact Username</label>
            <input type="text" id="contactUsername" placeholder="Enter username to add" />
        </div>
        <button id="addContactBtn" disabled>Add Contact</button>
    </div>
    </div>

    <script>
        // User profile management
        let savedProfiles = JSON.parse(localStorage.getItem('umocUserProfiles') || '[]');
        let activeProfile = null;

        // Regular socket and connection variables
        let socket = null;
        let currentSessionID = null;
        let pingInterval = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectInterval = 3000; // 3 seconds
        let reconnectTimer = null;
        let directChats = [];
        let groupChats = [];
        let selectedChatType = 'direct';

        // Keep track of login credentials for auto-reconnect
        let savedUsername = '';
        let savedPassword = '';
        let sessionExpiredDetected = false;
        let maxSessionRetries = 3;
        let sessionRetryCount = 0;

        // Typing indicator variables
        let typingTimeout = null;
        let isCurrentlyTyping = false;

        // DOM Elements
        const serverUrlInput = document.getElementById('serverUrl');
        const loginUsernameInput = document.getElementById('loginUsername');
        const loginPasswordInput = document.getElementById('loginPassword');
        const sessionIdInput = document.getElementById('sessionID');
        const loginBtn = document.getElementById('loginBtn');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const connectionStatus = document.getElementById('connectionStatus');
        const messageLog = document.getElementById('messageLog');

        const recipientIdInput = document.getElementById('recipientId');
        const messageContentInput = document.getElementById('messageContent');
        const messageTypeSelect = document.getElementById('messageType');
        const isGroupCheckbox = document.getElementById('isGroup');
        const sendMessageBtn = document.getElementById('sendMessageBtn');

        const chatIdInput = document.getElementById('chatId');
        const isGroupChatCheckbox = document.getElementById('isGroupChat');
        const getMessagesBtn = document.getElementById('getMessagesBtn');

        const getChatsBtn = document.getElementById('getChatsBtn');

        const contactUsernameInput = document.getElementById('contactUsername');
        const addContactBtn = document.getElementById('addContactBtn');

        const pingStatus = document.getElementById('pingStatus');
        const reconnectStatus = document.getElementById('reconnectStatus');
        const refreshChatsBtn = document.getElementById('refreshChatsBtn');
        const chatsList = document.getElementById('chatsList');
        const directChatsTab = document.getElementById('directChatsTab');
        const groupChatsTab = document.getElementById('groupChatsTab');

        const username = document.getElementById('username');
        const password = document.getElementById('password');
        const saveUserBtn = document.getElementById('saveUserBtn');
        const userProfiles = document.getElementById('userProfiles');
        const currentUsername = document.getElementById('currentUsername');

        // Initialize user profiles
        function initializeUserProfiles() {
            renderUserProfiles();

            // Set active profile from local storage
            const activeProfileId = localStorage.getItem('umocActiveProfile');
            if (activeProfileId) {
                const profile = savedProfiles.find(p => p.id === activeProfileId);
                if (profile) {
                    setActiveProfile(profile);
                }
            }
        }

        // Render user profiles
        function renderUserProfiles() {
            userProfiles.innerHTML = '';

            if (savedProfiles.length === 0) {
                const noProfiles = document.createElement('div');
                noProfiles.className = 'text-muted';
                noProfiles.textContent = 'No saved users. Add one above.';
                userProfiles.appendChild(noProfiles);
                return;
            }

            savedProfiles.forEach(profile => {
                const profileElement = document.createElement('div');
                profileElement.className = `user-profile ${profile.id === (activeProfile?.id) ? 'active' : ''}`;

                const nameElement = document.createElement('div');
                nameElement.textContent = profile.username;

                const actionsElement = document.createElement('div');
                actionsElement.className = 'profile-actions';

                const selectBtn = document.createElement('button');
                selectBtn.className = 'btn-sm';
                selectBtn.textContent = 'Select';
                selectBtn.addEventListener('click', () => setActiveProfile(profile));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn-sm btn-danger';
                deleteBtn.textContent = 'Delete';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteProfile(profile.id);
                });

                actionsElement.appendChild(selectBtn);
                actionsElement.appendChild(deleteBtn);

                profileElement.appendChild(nameElement);
                profileElement.appendChild(actionsElement);
                userProfiles.appendChild(profileElement);
            });
        }

        // Save a user profile
        saveUserBtn.addEventListener('click', () => {
            const newUsername = username.value.trim();
            const newPassword = password.value.trim();

            if (!newUsername || !newPassword) {
                alert('Please enter both username and password');
                return;
            }

            // Check if user already exists
            const existingIndex = savedProfiles.findIndex(p => p.username === newUsername);
            if (existingIndex >= 0) {
                // Update existing profile
                savedProfiles[existingIndex].password = newPassword;
                localStorage.setItem('umocUserProfiles', JSON.stringify(savedProfiles));
                renderUserProfiles();
                alert(`Updated password for ${newUsername}`);
            } else {
                // Create new profile
                const newProfile = {
                    id: Date.now().toString(),
                    username: newUsername,
                    password: newPassword,
                    sessionID: null
                };

                savedProfiles.push(newProfile);
                localStorage.setItem('umocUserProfiles', JSON.stringify(savedProfiles));
                renderUserProfiles();
                username.value = '';
                password.value = '';

                // If no active profile, set this as active
                if (!activeProfile) {
                    setActiveProfile(newProfile);
                }
            }
        });

        // Set active profile
        function setActiveProfile(profile) {
            activeProfile = profile;
            localStorage.setItem('umocActiveProfile', profile.id);

            // Update UI
            currentUsername.textContent = profile.username;
            sessionIdInput.value = profile.sessionID || '';
            loginUsernameInput.value = profile.username;
            loginPasswordInput.value = profile.password;

            // If already connected, disconnect first
            if (socket && socket.connected) {
                socket.disconnect();
            }

            renderUserProfiles();
        }

        // Delete a profile
        function deleteProfile(profileId) {
            if (confirm('Are you sure you want to delete this user?')) {
                savedProfiles = savedProfiles.filter(p => p.id !== profileId);
                localStorage.setItem('umocUserProfiles', JSON.stringify(savedProfiles));

                // If the active profile was deleted, clear it
                if (activeProfile && activeProfile.id === profileId) {
                    activeProfile = null;
                    localStorage.removeItem('umocActiveProfile');
                    currentUsername.textContent = 'None';
                }

                renderUserProfiles();
            }
        }

        // Update session ID for active profile
        function updateSessionID(sessionID) {
            if (activeProfile) {
                activeProfile.sessionID = sessionID;
                const index = savedProfiles.findIndex(p => p.id === activeProfile.id);
                if (index >= 0) {
                    savedProfiles[index].sessionID = sessionID;
                    localStorage.setItem('umocUserProfiles', JSON.stringify(savedProfiles));
                }
            }
        }

        // Login and Connect
        loginBtn.addEventListener('click', async () => {
            if (!activeProfile) {
                alert('Please select or create a user profile first');
                return;
            }

            // Use the active profile's credentials
            savedUsername = activeProfile.username;
            savedPassword = activeProfile.password;

            await performLogin(savedUsername, savedPassword);
        });

        // Perform login and get session ID
        async function performLogin(username, password) {
            const serverUrl = serverUrlInput.value;

            try {
                sessionRetryCount++;
                // First, get a session ID by logging in
                const loginUrl = `${serverUrl}/login?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`;
                logMessage(`Logging in as ${username}`, 'sent');

                const response = await fetch(loginUrl);
                const data = await response.json();

                if (!response.ok) {
                    logMessage(`Login failed: ${data.message || 'Unknown error'}`, 'error');
                    return false;
                }

                if (!data.sessionID) {
                    logMessage('Login successful but no session ID received', 'error');
                    return false;
                }

                logMessage(`Login successful! Session ID: ${data.sessionID}`, 'received');

                // Update the session ID input and connect
                sessionIdInput.value = data.sessionID;
                currentSessionID = data.sessionID;

                // Save the session ID to the active profile
                updateSessionID(data.sessionID);

                sessionExpiredDetected = false;
                sessionRetryCount = 0;
                connectWithSessionID(data.sessionID);
                return true;
            } catch (error) {
                logMessage(`Login error: ${error.message}`, 'error');
                return false;
            }
        }

        // Connect with Session ID
        connectBtn.addEventListener('click', () => {
            const sessionID = sessionIdInput.value;

            if (!sessionID) {
                logMessage('Please enter a session ID', 'error');
                return;
            }

            connectWithSessionID(sessionID);
        });

        // Helper function to connect with session ID
        function connectWithSessionID(sessionID) {
            const serverUrl = serverUrlInput.value;
            currentSessionID = sessionID;

            try {
                // Disconnect existing socket if any
                if (socket && socket.connected) {
                    socket.disconnect();
                }

                // Connect to Socket.IO server with session ID as query parameter
                socket = io(serverUrl, {
                    query: { sessionID },
                    transports: ['websocket', 'polling'],
                    reconnection: false, // We'll handle reconnection manually
                    forceNew: true,
                    timeout: 5000
                });

                socket.on('connect', () => {
                    connectionStatus.textContent = 'Connected';
                    connectionStatus.className = 'status connected';
                    connectBtn.disabled = true;
                    loginBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    sendMessageBtn.disabled = false;
                    getMessagesBtn.disabled = false;
                    getChatsBtn.disabled = false;
                    refreshChatsBtn.disabled = false;
                    addContactBtn.disabled = false;

                    reconnectAttempts = 0;
                    reconnectStatus.textContent = '';
                    clearInterval(reconnectTimer);

                    logMessage('Socket.IO connection established', 'received');
                    logMessage(`Socket ID: ${socket.id}`, 'received');

                    // Start ping interval
                    startPingInterval();

                    // Fetch chats immediately
                    fetchChats();
                });

                socket.on('connect_error', (error) => {
                    logMessage(`Connection error: ${error.message}`, 'error');

                    // Check if this could be a session expiration
                    if (error.message.includes('Session') || error.message.includes('Authentication') || error.message.includes('Authorization')) {
                        handlePossibleSessionExpiration();
                    } else {
                        // If not already attempting to reconnect, start reconnection process
                        if (!reconnectTimer) {
                            attemptReconnect();
                        }
                    }
                });

                // Handle various events from server
                socket.on('new_message', (data) => {
                    logMessage(`Received new message: ${JSON.stringify(data, null, 2)}`, 'received');

                    // Automatically mark messages as read when received
                    if (data.sender_id !== activeProfile?.id) {
                        markMessagesAsRead([data.message_id], data.sender_id);
                    }

                    // Refresh chats to update latest messages
                    fetchChats();
                });

                socket.on('typing_indicator', (data) => {
                    logMessage(`Typing indicator: ${data.username} is ${data.is_typing ? 'typing...' : 'stopped typing'}`, 'received');

                    // Update UI to show typing indicator
                    updateTypingIndicator(data);
                });

                socket.on('messages_read', (data) => {
                    logMessage(`Messages read by ${data.reader_username}: ${JSON.stringify(data.message_ids)}`, 'received');

                    // Update UI to show read status for these messages
                    updateReadStatus(data.message_ids);
                });

                socket.on('chat_history', (data) => {
                    logMessage(`Received chat history: ${data.messages.length} messages (page ${data.page}/${data.total_pages})`, 'received');

                    // Display messages in the chat area
                    displayChatHistory(data);
                });

                socket.on('chat_messages', (data) => {
                    logMessage(`Received chat messages: ${JSON.stringify(data, null, 2)}`, 'received');
                });

                socket.on('chats', (data) => {
                    logMessage(`Received chats: ${JSON.stringify(data, null, 2)}`, 'received');
                    if (Array.isArray(data)) {
                        processChats(data);
                    } else if (data && Array.isArray(data.chats)) {
                        processChats(data.chats);
                    }
                });

                socket.on('contact_added', (data) => {
                    logMessage(`Contact added: ${JSON.stringify(data, null, 2)}`, 'received');
                });

                socket.on('contact_request', (data) => {
                    logMessage(`Contact request received: ${JSON.stringify(data, null, 2)}`, 'received');
                });

                socket.on('user_status', (data) => {
                    logMessage(`User status update: ${JSON.stringify(data, null, 2)}`, 'received');
                });

                socket.on('error', (data) => {
                    logMessage(`Received error: ${JSON.stringify(data, null, 2)}`, 'error');

                    // Check if this could be a session expiration
                    if (typeof data === 'string' && (data.includes('session') || data.includes('auth'))) {
                        handlePossibleSessionExpiration();
                    } else if (data && data.message && (data.message.includes('session') || data.message.includes('auth'))) {
                        handlePossibleSessionExpiration();
                    }
                });

                // Generic catch-all for other events
                socket.onAny((eventName, ...args) => {
                    if (!['new_message', 'chat_messages', 'chats', 'error', 'contact_added', 'contact_request', 'user_status'].includes(eventName)) {
                        logMessage(`Received '${eventName}' event: ${JSON.stringify(args, null, 2)}`, 'received');
                    }
                });

                socket.on('pong', (data) => {
                    updatePingStatus(data.latency);
                });

                socket.on('disconnect', (reason) => {
                    connectionStatus.textContent = 'Disconnected';
                    connectionStatus.className = 'status disconnected';
                    disableControlButtons();
                    logMessage(`Disconnected: ${reason}`, 'received');
                    clearInterval(pingInterval);
                    pingStatus.textContent = '';

                    // Check if this was due to a session expiration
                    if (sessionExpiredDetected) {
                        handleSessionExpiration();
                    }
                    // Auto-reconnect if not intentionally disconnected
                    else if (reason !== 'io client disconnect') {
                        attemptReconnect();
                    }
                });

            } catch (error) {
                logMessage(`Failed to connect: ${error.message}`, 'error');
            }
        }

        // Disable all control buttons
        function disableControlButtons() {
            connectBtn.disabled = false;
            loginBtn.disabled = false;
            disconnectBtn.disabled = true;
            sendMessageBtn.disabled = true;
            getMessagesBtn.disabled = true;
            getChatsBtn.disabled = true;
            refreshChatsBtn.disabled = true;
            addContactBtn.disabled = true;
        }

        // Attempt to reconnect
        function attemptReconnect() {
            if (reconnectAttempts >= maxReconnectAttempts) {
                reconnectStatus.textContent = 'Max reconnection attempts reached. Please reconnect manually.';
                clearInterval(reconnectTimer);
                reconnectTimer = null;
                return;
            }

            reconnectAttempts++;
            reconnectStatus.textContent = `Reconnecting... Attempt ${reconnectAttempts}/${maxReconnectAttempts}`;

            if (!reconnectTimer) {
                reconnectTimer = setInterval(() => {
                    if (socket && socket.connected) {
                        clearInterval(reconnectTimer);
                        reconnectTimer = null;
                        return;
                    }

                    logMessage(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`, 'sent');
                    connectWithSessionID(currentSessionID);

                }, reconnectInterval);
            }
        }

        // Start ping interval
        function startPingInterval() {
            clearInterval(pingInterval);
            pingInterval = setInterval(() => {
                if (socket && socket.connected) {
                    const start = Date.now();
                    socket.emit('ping', { timestamp: start });

                    // If server doesn't respond with pong in 5 seconds, consider connection lost
                    setTimeout(() => {
                        if (Date.now() - start > 5000) {
                            updatePingStatus(null);
                        }
                    }, 5000);
                }
            }, 10000); // Ping every 10 seconds
        }

        // Update ping status
        function updatePingStatus(latency) {
            if (latency === null) {
                pingStatus.textContent = 'Connection unstable';
                pingStatus.style.color = '#ff9800';
            } else {
                pingStatus.textContent = `Ping: ${latency}ms`;

                if (latency < 100) {
                    pingStatus.style.color = '#4caf50';
                } else if (latency < 300) {
                    pingStatus.style.color = '#ff9800';
                } else {
                    pingStatus.style.color = '#f44336';
                }
            }
        }

        // Disconnect from Socket.IO
        disconnectBtn.addEventListener('click', () => {
            if (socket) {
                clearInterval(pingInterval);
                clearInterval(reconnectTimer);
                reconnectTimer = null;
                pingStatus.textContent = '';
                reconnectStatus.textContent = '';
                socket.disconnect();
                socket = null;
            }
        });

        // Process and display chats
        function processChats(chats) {
            if (!Array.isArray(chats)) {
                logMessage('Received invalid chats data', 'error');
                return;
            }

            directChats = chats.filter(chat => !chat.is_group);
            groupChats = chats.filter(chat => chat.is_group);

            displayChats();
        }

        // Display chats based on selected tab
        function displayChats() {
            const chatsToDisplay = selectedChatType === 'direct' ? directChats : groupChats;
            chatsList.innerHTML = '';

            if (chatsToDisplay.length === 0) {
                const noChatsElement = document.createElement('div');
                noChatsElement.textContent = `No ${selectedChatType} chats found`;
                noChatsElement.className = 'text-muted';
                noChatsElement.style.padding = '10px';
                chatsList.appendChild(noChatsElement);
                return;
            }

            chatsToDisplay.forEach(chat => {
                const chatElement = document.createElement('div');
                chatElement.className = 'chat-item';
                chatElement.dataset.chatId = chat.id || chat.chat_id;
                chatElement.dataset.isGroup = selectedChatType === 'group';

                const nameElement = document.createElement('div');
                nameElement.textContent = chat.name || chat.username || `Chat ${chat.id || chat.chat_id}`;
                nameElement.style.fontWeight = 'bold';

                const lastMessageElement = document.createElement('div');
                lastMessageElement.className = 'text-muted';
                lastMessageElement.textContent = chat.last_message ?
                    `Last message: ${truncateText(chat.last_message.content, 30)}` :
                    'No messages yet';

                chatElement.appendChild(nameElement);
                chatElement.appendChild(lastMessageElement);

                // If there are unread messages, show count
                if (chat.unread_count > 0) {
                    const badge = document.createElement('span');
                    badge.className = 'badge';
                    badge.textContent = chat.unread_count;
                    nameElement.appendChild(badge);
                }

                // Add click handler
                chatElement.addEventListener('click', () => {
                    // Remove selected class from all chats
                    document.querySelectorAll('.chat-item').forEach(item => {
                        item.classList.remove('selected');
                    });

                    // Add selected class to clicked chat
                    chatElement.classList.add('selected');

                    // Populate the get messages form
                    chatIdInput.value = chat.id || chat.chat_id;
                    isGroupChatCheckbox.checked = selectedChatType === 'group';

                    // If sending a message, also populate recipient ID
                    recipientIdInput.value = chat.id || chat.chat_id;
                    isGroupCheckbox.checked = selectedChatType === 'group';
                });

                chatsList.appendChild(chatElement);
            });
        }

        // Helper function to truncate text
        function truncateText(text, maxLength) {
            if (!text) return '';
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        // Fetch chats
        function fetchChats() {
            if (!socket || !socket.connected) {
                logMessage('Socket.IO is not connected', 'error');
                return;
            }

            const messageData = {
                sessionID: currentSessionID
            };

            socket.emit('get_chats', messageData);
            logMessage(`Sent 'get_chats' event: ${JSON.stringify(messageData, null, 2)}`, 'sent');
        }

        // Tab switching
        directChatsTab.addEventListener('click', () => {
            directChatsTab.classList.add('active');
            groupChatsTab.classList.remove('active');
            selectedChatType = 'direct';
            displayChats();
        });

        groupChatsTab.addEventListener('click', () => {
            groupChatsTab.classList.add('active');
            directChatsTab.classList.remove('active');
            selectedChatType = 'group';
            displayChats();
        });

        // Refresh chats
        refreshChatsBtn.addEventListener('click', fetchChats);

        // Send a message
        sendMessageBtn.addEventListener('click', () => {
            if (!socket || !socket.connected) {
                logMessage('Socket.IO is not connected', 'error');
                return;
            }

            const recipientId = recipientIdInput.value;
            const content = messageContentInput.value;
            const type = messageTypeSelect.value;
            const isGroup = isGroupCheckbox.checked;

            if (!recipientId) {
                logMessage('Please enter a recipient ID', 'error');
                return;
            }

            if (!content) {
                logMessage('Please enter a message', 'error');
                return;
            }

            try {
                // Store message in case we need to retry
                const savedMessage = {
                    recipientId,
                    content,
                    type,
                    isGroup
                };

                // Properly format the message event with correct structure
                const messageData = {
                    sessionID: currentSessionID,
                    recipient_id: recipientId,
                    content,
                    type,
                    is_group: isGroup
                };

                // Log before sending to help with debugging
                logMessage(`Sending message: ${JSON.stringify(messageData, null, 2)}`, 'sent');

                // Don't use a callback function here, as it might be causing issues
                socket.emit('send_message', messageData);

                // Clear the message input on success
                messageContentInput.value = '';

                // Stop typing indicator when sending a message
                sendTypingIndicator(recipientId, isGroup, false);

            } catch (error) {
                logMessage(`Error sending message: ${error.message}`, 'error');
            }
        });

        // Add typing indicator detection on message input
        messageContentInput.addEventListener('input', () => {
            const recipientId = recipientIdInput.value;
            const isGroup = isGroupCheckbox.checked;

            if (!recipientId || !socket || !socket.connected) return;

            // Clear previous timeout
            if (typingTimeout) clearTimeout(typingTimeout);

            // Only send typing indicator if not already typing
            if (!isCurrentlyTyping) {
                sendTypingIndicator(recipientId, isGroup, true);
                isCurrentlyTyping = true;
            }

            // Set timeout to stop typing indicator after 3 seconds of no input
            typingTimeout = setTimeout(() => {
                sendTypingIndicator(recipientId, isGroup, false);
                isCurrentlyTyping = false;
            }, 3000);
        });

        // Function to send typing indicator
        function sendTypingIndicator(recipientId, isGroup, isTyping) {
            if (!socket || !socket.connected) return;

            socket.emit('typing', {
                sessionID: currentSessionID,
                recipient_id: recipientId,
                is_typing: isTyping,
                is_group: isGroup
            });
        }

        // Function to update typing indicator in UI
        function updateTypingIndicator(data) {
            const typingIndicator = document.getElementById('typingIndicator');

            if (!typingIndicator) {
                // Create typing indicator element if it doesn't exist
                const indicatorElement = document.createElement('div');
                indicatorElement.id = 'typingIndicator';
                indicatorElement.className = 'typing-indicator';
                messageLog.appendChild(indicatorElement);
            }

            const indicatorElement = document.getElementById('typingIndicator');

            if (data.is_typing) {
                indicatorElement.textContent = `${data.username} is typing...`;
                indicatorElement.style.display = 'block';

                // Auto-hide after 5 seconds in case the "stopped typing" event is missed
                setTimeout(() => {
                    if (indicatorElement.textContent.includes(data.username)) {
                        indicatorElement.style.display = 'none';
                    }
                }, 5000);
            } else {
                // Check if this was the user that was shown as typing
                if (indicatorElement.textContent.includes(data.username)) {
                    indicatorElement.style.display = 'none';
                }
            }
        }

        // Function to mark messages as read
        function markMessagesAsRead(messageIds, senderId) {
            if (!socket || !socket.connected || !messageIds.length) return;

            socket.emit('read_receipt', {
                sessionID: currentSessionID,
                message_ids: messageIds,
                sender_id: senderId
            });
        }

        // Function to update read status in UI
        function updateReadStatus(messageIds) {
            // Add CSS class to show messages as read
            messageIds.forEach(id => {
                const msgElement = document.getElementById(`msg-${id}`);
                if (msgElement) {
                    msgElement.classList.add('read');

                    // Add or update the read status indicator
                    let readIndicator = msgElement.querySelector('.read-indicator');
                    if (!readIndicator) {
                        readIndicator = document.createElement('span');
                        readIndicator.className = 'read-indicator';
                        msgElement.appendChild(readIndicator);
                    }
                    readIndicator.textContent = '✓ Read';
                }
            });
        }

        // Function to display chat history
        function displayChatHistory(data) {
            // Clear message area if it's the first page
            if (data.page === 1) {
                document.getElementById('chatMessages').innerHTML = '';
            }

            const messagesContainer = document.getElementById('chatMessages');

            // Display messages
            data.messages.forEach(msg => {
                const isFromMe = msg.sender_id === activeProfile?.id;

                const messageElement = document.createElement('div');
                messageElement.id = `msg-${msg.message_id}`;
                messageElement.className = `chat-message ${isFromMe ? 'outgoing' : 'incoming'}`;

                // Create message content
                const contentElement = document.createElement('div');
                contentElement.className = 'message-content';

                // Handle different message types
                if (msg.type === 'text') {
                    contentElement.textContent = msg.content;
                } else {
                    // For other types like images, etc.
                    contentElement.textContent = `[${msg.type}] ${msg.content}`;
                }

                // Create message info
                const infoElement = document.createElement('div');
                infoElement.className = 'message-info';
                infoElement.textContent = `${isFromMe ? 'You' : msg.sender_username} • ${formatTimestamp(msg.timestamp)}`;

                // Add read indicator if it's my message and it's been read
                if (isFromMe && msg.read) {
                    const readIndicator = document.createElement('span');
                    readIndicator.className = 'read-indicator';
                    readIndicator.textContent = '✓ Read';
                    infoElement.appendChild(readIndicator);
                }

                messageElement.appendChild(contentElement);
                messageElement.appendChild(infoElement);
                messagesContainer.appendChild(messageElement);
            });

            // Add load more button if there are more pages
            if (data.page < data.total_pages) {
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.textContent = `Load More (${data.page}/${data.total_pages})`;
                loadMoreBtn.className = 'load-more-btn';
                loadMoreBtn.onclick = () => loadMoreMessages(data.chat_id, data.is_group, data.page + 1);
                messagesContainer.appendChild(loadMoreBtn);
            }

            // Scroll to bottom if it's the first page
            if (data.page === 1) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // Function to load more messages
        function loadMoreMessages(chatId, isGroup, page) {
            if (!socket || !socket.connected) {
                logMessage('Socket.IO is not connected', 'error');
                return;
            }

            socket.emit('get_chat_history', {
                sessionID: currentSessionID,
                chat_id: chatId,
                is_group: isGroup,
                page: page,
                page_size: 20
            });
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();

            // If today, just show time
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            // If this year, show date and time
            if (date.getFullYear() === now.getFullYear()) {
                return date.toLocaleDateString([], { month: 'short', day: 'numeric' }) +
                    ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            // Otherwise show full date
            return date.toLocaleDateString() + ' ' +
                date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Add a contact
        addContactBtn.addEventListener('click', () => {
            if (!socket || !socket.connected) {
                logMessage('Socket.IO is not connected', 'error');
                return;
            }

            const contactUsername = contactUsernameInput.value;

            if (!contactUsername) {
                logMessage('Please enter a contact username', 'error');
                return;
            }

            const data = {
                sessionID: currentSessionID,
                contact_username: contactUsername
            };

            socket.emit('add_contact', data);
            logMessage(`Sent 'add_contact' event: ${JSON.stringify(data, null, 2)}`, 'sent');
            contactUsernameInput.value = '';
        });

        // Helper function to log messages
        function logMessage(message, type) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${type}`;

            // Handle objects and format them nicely
            if (typeof message === 'object') {
                const pre = document.createElement('pre');
                pre.textContent = JSON.stringify(message, null, 2);
                messageElement.appendChild(pre);
            } else {
                messageElement.textContent = message;
            }

            messageLog.appendChild(messageElement);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        // Handle potential session expiration
        function handlePossibleSessionExpiration() {
            logMessage('Potential session expiration detected', 'error');
            sessionExpiredDetected = true;
        }

        // Handle confirmed session expiration by re-logging in
        function handleSessionExpiration() {
            logMessage('Session expired. Attempting to re-login...', 'error');

            // If we have saved credentials and haven't tried too many times
            if (savedUsername && savedPassword && sessionRetryCount < maxSessionRetries) {
                logMessage(`Re-login attempt ${sessionRetryCount}/${maxSessionRetries}`, 'sent');

                // Wait a moment before trying to re-login
                setTimeout(async () => {
                    const success = await performLogin(savedUsername, savedPassword);
                    if (!success && sessionRetryCount < maxSessionRetries) {
                        // Try again after a delay
                        setTimeout(() => handleSessionExpiration(), 5000);
                    } else if (!success) {
                        logMessage('Max re-login attempts reached. Please log in manually.', 'error');
                    }
                }, 1000);
            } else {
                logMessage('Cannot automatically re-login. Please log in manually.', 'error');
            }
        }

        // Initialize user profiles when the page loads
        document.addEventListener('DOMContentLoaded', initializeUserProfiles);
    </script>
</body>

</html>